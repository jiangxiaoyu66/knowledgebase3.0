## 网络安全攻击方式有哪些，什么特点？如何预防？



网络攻击方式有很多种，最常见的属于跨站脚本攻击和跨站请求伪造了。

### 跨站脚本攻击

 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

>XSS 可以分为存储型、反射型和 DOM 型：
>
>- 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
>- 反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 
>- DOM 型：网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。
>
>



### 跨站请求伪造

跨站请求伪造，缩写为crsf。csrf是通过用户登陆后服务端返回的cookie，进行伪造身份，从而发起的一种攻击，比如伪造你的身份去银行取钱。所以crsf的后果往往是不可逆的，但是他的执行条件比较多。需要用户在登录条件下访问了第三方的病毒网站，且需要攻击者了解被攻击网站的内部代码，从而摸清哪里有csrf漏洞。

### 其他

除了这两种最常见的之外，还有一些，比如：点击劫持，url跳转漏洞

点击劫持，就是在一些敏感操作，比如登录的按钮上门，隐藏一个透明的iframe，诱导用户点击。

url跳转漏洞，就是在点击网站链接进行跳转的时候，没有对跳转的地址进行合法性验证，导致用户跳转到钓鱼页面。



### XSS如何防范？

将用户输入的可能产生XSS攻击的尖括号,引号等进行转义(不要相信任何用户的输入,都要验证或转义)

### crsf如何防范？

如何防范：

>- 可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
>- 使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
>
>> 1. CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
>> 2. 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 
>
>- 对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。
>





## 跨域解决方案有哪些？



```
CORS：一种w3c标准，它允许跨域请求。做法：服务端设置 Access-Control-Allow-Origin 
代理：正向或者反向代理。如webpack中可以在devserver中设置proxy，正向为node控制，反向为nginx转发
jsonp：利用script标签运行跨域的特性
postMessage运行跨域

```



#### 简述HTTP请求的方法字段，get和post的区别

http/1.0规定了三种请求方法：GET、POST、HEAD
http/1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE、CONNECT

- **GET**：常用于获取数据，幂等

- **POST**：创建数据。非幂等：当多次发送相同的POST请求，服务器上的资源数目可能会增加

- **PUT**：修改数据。幂等：PUT请求后服务器上的资源数目不会增加，每次PUT都会覆盖前一次PUT的资源

- **DELETE**：请求删除指定资源。（客户端发送了此请求，删除操作也不一定会执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求）

- **HEAD**：获取相应报头

  使用场景：在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源

- **OPTIONS**：列出可对资源实行的请求方式，用来跨域请求，成功后会在HTTP响应头中包含一个名为“Allow”的头，其值就是当前支持的请求方式

- **TRACE**：请求服务器回送收到的请求信息，主要用于测试或诊断。服务端在相应主体中携带它收到的原始请求报文的最终模样，客户端可以查看HTTP请求报文在发送过程中是否被修改

- **CONNECT**：建立连接隧道，用于代理服务器 

幂等性：GET 请求是一个幂等的请求，一般指用来获取资源，不会对服务器资源产生修改。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。



#### 请求方法的区别

**get和post的区别**

1、get参数暴露在url中，不安全，且有长度限制。参数的数据类型只接受字符串，post无限制

2、幂等性：GET 请求是一个幂等的请求，一般指用来获取资源，不会对服务器资源产生修改。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。

3、**从TCP角度来看，GET产生一个TCP数据包，浏览器会把http header和data一并发送，服务器响应200 OK并返回数据；POST产生两个TCP数据包，浏览器先发送http header，服务器响应100 continue，浏览器再发送data，服务器响应200 OK并返回数据（火狐只发送一次）**

### HTTP状态码

状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：

- 1xx：指示信息 – 表示请求已接收，继续处理
- 2xx：成功 – 表示请求已被成功接收
- 3xx：重定向 – 要完成请求必须进行更进一步的操作
- 4xx：客户端错误 – 请求有语法错误或请求无法实现
- 5xx：服务器错误 – 服务器未能实现合法的请求

```
- **200** OK：客户端请求成功
- **204** No Content：没有新文档，浏览器应该继续显示原来的文档
- 206 Partial Content：客户发送了一个带有Range头的GET请求，服务器完成了它
- **301** Moved Permanently：永久重定向
- 302 Found：所请求的页面已经临时转移至新的url
- **304 Not Modified：协商缓存命中**
- **400** Bad Request：客户端请求有语法错误，不能被服务器所理解
- 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
- 403 Forbidden：对被请求页面的访问被禁止，服务器不允许访问该页面
- **404** Not Found：请求资源不存在
- **500** Internal Server Error：服务器发生不可预期的错误
- 503 Server Unavailable：请求未完成，服务器临时过载或当机，一段时间后可能恢复正常
```



#### 11 http2.0 做了哪些改进 3.0 呢 

```
http0.9: 只有get请求+html格式的字符串
http1.0: 
post+请求头的概念+非标准化的长连接（connection：keep-alive）+初步的缓存控制（expires和Last-Modified）
http1.1：默认长连接+管道机制+缓存控制（cache-control + ETag）+断点续传（Range）+虚拟网络+新的请求方法
http1.1问题：传输数据都是明文+同一TCP连接容易队头阻塞+只要请求一次的情况下还是会保持持久连接，增加服务器压力
http2.0：二进制分帧且不分先后关系 + 多路复用+ 头部压缩 + 服务器推送
```



```
http2.0缺点：丢包后整个tcp连接中所有的请求都要等待丢包重传后才能正常完成请求 + tcp和TLS建立连接的延时
http3.0：tcp换成udp + QUIC(实现可靠传输) 
```

## TCP和UDP

总结：
TCP一对一建立连接，能保证不会丢包（序号机制）。适合追求数据完整性的场景
UDP无需建立连接，支持多对多通信，传输快，传输容量更大。适合追求实时性的场景



