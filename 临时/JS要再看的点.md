

## 手写题和输出题





## Promise的手写



## ==和===， Object.is的区别

```
==:自动转换数据类型，
===: NaN不等于自身，以及+0等于-0。
es6新的方法Object.is来比较两个值严格相等，它与严格比较运算符（===）基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
```

===严格判断，**==如果类型不一致会进行隐式类型转换**



## JavaScript 中如何进行隐式类型转换？

 [隐式类型转换.md](隐式类型转换.md) 

```
String和NUmber：转为Number类型（字符串全是数字的时候转为对应数字，''转为0，其余转为NaN）
Boolean和其他原始类型：不管和谁进行比较，都会先转换为Number进行比较（0或1）
null和undefined：JS规定`null==undefined`，并且都与自身相等，但是与其他所有值都不宽松相等。

对象和原型类型进行比较，根据下面的规则先把对象转换为基本数据类型：
1、除了特殊的Date以外的对象，先调用ValueOf()，如果还不是原始类型，则调用toString(),如果得到的返回值还不是原始类型，则报错
2、对于Date对象，先toString(),再valueOf()
```

#### null和undefined的区别

意义上来说，null代表“没有对象”，没有值； undefined代表“缺少值”，声明了但是未赋值

用法上：

```js
// null1.原型链的终点2.作为函数参数，代表参数不是对象
// undefined1.变量声明但是没有赋值2.如果函数调用未给参数，则是undefined3.函数默认返回值为undefined
```

#### null是对象吗

虽然 typeof null 返回的值是 object,但是null不是对象，而是基本数据类型的一种

#### 基本数据类型和复杂数据类型的区别

- 基本数据类型存储在栈内存，存储的是值。
- 复杂数据类型的值存储在堆内存，地址（指向堆中的值）存储在栈内存。当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。

























## 执行上下文的变量对象

### 创建阶段

变量对象会包括：

1. 函数的所有形参 (如果是函数上下文)
   - 由名称和对应值组成的一个变量对象的属性被创建
   - 没有实参，属性值设为 undefined
2. 函数声明
   - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
   - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
   - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性

重名：

同名的变量声明：忽略原则，后声明的会被忽略

同名的函数声明：覆盖原则，先声明的会被覆盖

变量和函数同名：函数声明有效（因为提升时函数声明会提升到变量声明之前，变量声明一定会被忽略 ）



### 如何回收闭包

通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

**如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。**

所以在使用闭包的时候，你要尽量注意一个原则：**如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。**

##  什么是事件代理（事件委托） 有什么好处

```
把监听事件绑定到父节点，通过事件冒泡来触发父节点上的事件

好处：
1、这样只在内存中开辟一块空间，既节省资源又减少DOM操作，提高性能。
2、动态绑定事件，列表新增元素不用进行重新绑定了

```

```
拓展：
说一下事件流
答：指事件在dom树结构中传播的顺序，应该是三个阶段。1）事件捕获 2）处于目标阶段 3）事件冒泡
捕获：由父节点到子节点   冒泡则反之
```

# 深入了解 JavaScript 中的 for 循环



```
for in ： 遍历的是对象的所有属性，包括原型对象上的属性。遍历数组的时候数组元素的顺序可能是随机的
forEach 的速度不如 for，不能break和return
for of：
1、支持break, continue, return
2、支持数组，类数组，和Set，Map等可迭代对象；但是不支持普通对象
3、不会遍历原型对象上的属性


```



## 数组有哪些原生方法？

- 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。

- 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。

- 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。

- 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。

- 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。

- 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法

  some()：只要有一个是true，便返回true；every()：只要有一个是false，便返回false.

- 数组归并方法 reduce() 和 reduceRight() 方法，reduce()对数组正序操作；reduceRight()对数组逆序操作





```
影响原数组的api： splice
不影响的：slice(start, end), concat

添加：unshift(),push()
删除：shift(),pop()
排序：reverse(), sort()
```











