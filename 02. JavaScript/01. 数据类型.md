# 数据类型

## 有哪些数据类型

基本数据类型（栈）：布尔，数字（Number和BigInt），字符串，空和未定义，Symbol

引用数据类型（堆）：Object

### BigInt

任意大的整数

### Number

常规数字或者NaN

####  为什么0.1+0.2 ! == 0.3，如何让其相等  

>js中Number类型的实现原理是：
>
>遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。

下面看一下**双精度数是如何保存**的： ![img](图片/0cb225cf71d748a8b2d6a5615e402711tplv-k3u1fbpfcp-watermark.awebp)

- 第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位
- 第二部分（绿色）：用来存储指数（exponent），占用11位
- 第三部分（红色）：用来存储小数（fraction），占用52位

*双精度浮点数*(double)是计算机使用的一种数据类型，使用 64 位（8字节） 来存储一个浮点数。 它可以表示十进制的15或16位有效数字



#### isNaN 和 Number.isNaN 函数的区别？

 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换

isNaNh会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断











### Symbol

表示独一无二。它通过 `Symbol` 函数生成。一般用作属性名，保证不与其他属性名冲突

注意：

Symbol做属性名时，

**1、不能用点运算符访问（只能通过obj[Symbol]）**

**2、不能被遍历，想要遍历获取只能通过Object.getOwnPropertySymbols()**





### null和undefined的区别

undefined表示未定义，null表示有值，但值为空

不同点：type of的结果不一样



为什么 typeof null 的结果是Object？

```
第一版的js中用32位来存储值，前1-3位表示数据类型,000表示对象。而null指针的值全是0，所以被判断为Object
```

>000: object   - 当前存储的数据指向一个对象。
>1: int      - 当前存储的数据是一个 31 位的有符号整数。
>010: double   - 当前存储的数据指向一个双精度的浮点数。
>100: string   - 当前存储的数据指向一个字符串。
>110: boolean  - 当前存储的数据是布尔值。



>用一句话总结两者的区别就是：
>undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。
>
>



## 判断数据类型

- typeof可以正确判断除了null以外的基本数据类型，可以判断function的对象类型
- instanceof也不准确，他的原理是查看原型是否在原型链上（如：A instanceof B是用来判断B的原型是否在A的原型链上）



### 判断引用数据类型

通过原型链：instanceof，arr.constructor，

字符串：Object.prototype.toString.call()

toString是Object的原型方法，而Array、function等**类型作为Object的实例，都重写了toString方法**

### 判断基本数据类型

typeOf判断除了null以外的基本数据类型，null可以做单独判断

判断null

- 最简单的是通过`null===null`来判断是否为null
- `Object.prototype.__proto__===a`判断a是否为原始对象原型的原型即null

判断是否为NaN

- `isNaN(any)`直接调用此方法判断是否为非数值

一些其他判断

- `Object.is(a,b)`判断a与b是否完全相等，与===基本相同，不同点在于Object.is判断`+0不等于-0`，`NaN等于自身`





### 为什么typeof可以检测类型，有没有更好的方法

> js在底层存储变量的时候会在变量的机器码的低位1-3位存储其类型信息(000：对象，010：浮点数，100：字符串，110：布尔，1：整数)，但是null所有机器码均为0，直接被当做了对象来看待。 那么有没有更好的办法区分类型呢，一般使用Object.prototype.toString.call()





## ==和===， Object.is的区别

```
==:自动转换数据类型，
===: NaN不等于自身，以及+0等于-0。
es6新的方法Object.is来比较两个值严格相等，它与严格比较运算符（===）基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
```

===严格判断，**==如果类型不一致会进行隐式类型转换**

来看下《Javascript高级程序设计》关于==和===的规则

> 1.如果有一个操作数是布尔值，则在比较前先将其转换为数值，true转换为1，false转换为0，例如false == 0，true == 1
> 2.如果一个操作数是字符串，另一个操作数是数值，先将字符串转换成数值，例如"1"==1,'' ==0
> 3.如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型按照前面的规则进行比较。**(解释不清楚)**
> 4.null和undefined是相等的。
> 5.如果有一个数是NaN，则相等操作符返回false，而不相等操作符返回true。NaN == NaN返回为false，因为规则如此。
> 6.如果两个操作数是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true，否则返回false。
> 例如：var obj = {a:1};foo = obj;bar = obj;foo==bar;foo==bar返回为true，因为他们指向同一个对象，obj。

即：

- boolean则转为数值
- 对象和基本数据类型：valueOf()
- 有NaN，则结果为false
- 对象和对象：看引用地址是否一样
- null == undefined

![image-20210115174901723](图片/XG2W1RKxSVqwd3n.png)





## JavaScript 中如何进行隐式类型转换？

 [隐式类型转换.md](隐式类型转换.md) 

```
String和NUmber：转为Number类型（字符串全是数字的时候转为对应数字，''转为0，其余转为NaN）
Boolean和其他原始类型：不管和谁进行比较，都会先转换为Number进行比较（0或1）
null和undefined：JS规定`null==undefined`，并且都与自身相等，但是与其他所有值都不宽松相等。

对象和原型类型进行比较，根据下面的规则先把对象转换为基本数据类型：
1、除了特殊的Date以外的对象，先调用ValueOf()，如果还不是原始类型，则调用toString(),如果得到的返回值还不是原始类型，则报错
2、对于Date对象，先toString(),再valueOf()
```





## 面试题

#### null和undefined的区别

意义上来说，null代表“没有对象”，没有值； undefined代表“缺少值”，声明了但是未赋值

用法上：

```js
// null1.原型链的终点2.作为函数参数，代表参数不是对象
// undefined1.变量声明但是没有赋值2.如果函数调用未给参数，则是undefined3.函数默认返回值为undefined
```

#### null是对象吗

虽然 typeof null 返回的值是 object,但是null不是对象，而是基本数据类型的一种

#### 基本数据类型和复杂数据类型的区别

- 基本数据类型存储在栈内存，存储的是值。
- 复杂数据类型的值存储在堆内存，地址（指向堆中的值）存储在栈内存。当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。

#### JSON

JSON.stringify 函数：把对象转化为 JSON 格式的字符串

JSON.parse() 函数：把字符串转化为对象

