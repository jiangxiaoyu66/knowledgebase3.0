

## let，const，var的区别

```
总结：
var声明的是全局变量且可以重复声明；const和let声明变量存在于块级作用域，存在暂时性死区（必须声明后才可以访问）
const声明常量且必须赋值，let声明变量可不用赋值
```



### let和const之间

1. let声明常量，const声明变量

2. let声明时可以不赋值，const声明时候必须赋值

### var和let，const之间

1. var存在变量提升，let和const不存在

2. var可以重复声明，let和const不可以

3. var声明的变量是全局作用域，const和let声明的变量是块级作用域

```js
  var a = 1;
  //  window.a = 1
```

4. let和const存在暂时性死区

   

```js
var value = "global";

// 例子1
(function() {
    console.log(value); // Uncaught ReferenceError: value is not defined

    let value = 'local';
}());

// 例子2
{
    console.log(value); // Uncaught ReferenceError: value is not defined

    const value = 'local';
};
```

虽然在执行上下文中，所有的除形参和函数以外的变量都是先声明，后赋值的。但是let和const额外还有一个机制，叫做暂时性死区。即只有在执行过变量声明语句后，变量才可以被访问，否则就报错。



```
块级作用域：解决了ES5中的两个问题：
- 内层变量可能覆盖外层变量
- 用来计数的循环变量泄露为全局变量

变量提升：变量只能在声明之后使用，否在会报错。

给全局添加属性：浏览器的全局对象是window，Node的全局对象是global。var声明的是全局变量。

重复声明：var可以重复声明变量，后声明的同名变量会覆盖之前的。const和let不允许重复声明变量。

暂时性死区：在用let、const声明变量之前，该变量都是不可用的。var声明的变量不存在暂时性死区。

初始值设置：const必须设置初始值，let和var不用

```




### let声明不会变量提升与暂时性死区的原因

#### 用词法环境对象来解释这种原因

**其实let与var一样也存在着“变量提升”这种行为**，但是我们要清楚，变量的创建，初始化，赋值是三个不同的过程，在JS编译的词法分析过程中，会创建一个名叫**词法环境对象的规范对象**（它仅仅是存在于编程语言规范中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。），它会扫描当前执行的脚本/函数/代码块，将所有声明的变量，函数，参数全都填充为自己的属性(之后要访问这些变量时直接到词法环境对象中的属性中查找，即查找脚本/函数中的变量就是查找其词法环境对象的属性)。**用var声明的变量会同时提升自己的创建和初始化阶段，即在词法环境对象填充变量时即将变量初始化为undefined。而let声明的变量仅仅是提升了自己的创建阶段，并没有提升自己的初始化阶段(与var声明的区别)，**

**ES6中规定了let声明的变量的初始化阶段是在执行上下文的执行阶段而非创建阶段(即直到它们的定义被执行时才开始初始化)**

参考链接：https://juejin.cn/post/6956834149160189965





### 循环中的块级作用域

- 循环中的绑定块作用域的妙用

开发者可能最希望实现for循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，例如：

```
for (let i = 0; i < 10; i++) {
  // ...
}
console.log(i);
// ReferenceError: i is not defined
复制代码
```

上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。

```
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
复制代码
```

上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。

如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。

```js
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
复制代码
```

**上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。**

另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

```
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
复制代码
```

上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。

