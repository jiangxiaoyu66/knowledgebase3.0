## 手写instanceOf

原理：**测试构造函数的prototype是否在实例的原型链上**

```js
while (x.__proto__) {
 if (x.__proto__ === y.prototype) {
  	 return true;
 }
 x.__proto__ = x.__proto__.__proto__;
}
if (x.__proto__ === null) {	
 return false;
}
```

## 防抖节流

### 防抖

在规定的时间内如果重复触发某一个事件，将以最后一次事件的时间为准


```js
 // 防抖函数
function debounce (fn, delay) {
  var timer; // 维护一个 timer

  return function () {
    var _this = this; // 取debounce执行作用域的this
    var args = arguments;

    console.log(222);

    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(function () {
      fn.apply(_this, args); // 用apply指向调用debounce的对象，相当于_this.fn(args);
    }, delay);
  };
}

```

### 节流

每隔一段时间只执行一次事件

```js
//  第一版——使用时间戳
function throttle(func, wait) {
  let previous = 0;

  return function(...args) {
    const context = this;

    const now = new Date();
    if (now - previous > wait) {
      func.apply(context, args);
      previous = now;
    }
  }
}
```



```js
//  第一版——使用定时器
function throttle(func, wait) {
  let intervalId = 0;

  return function(...args) {
    const context = this;

    if (!intervalId) {
      intervalId = setInterval(() => {
        func.apply(context, args);
        intervalId = 0;
      }, wait)
    }
  }
}
```

## 手写new

```js
function newFunction(ConsFun, ...rest){
    const obj = {}
    obj._proto_ = ConsFun.prototype; // 继承原型
    const result = this.apply(obj, rest); // 执行ConsFun构造函数中的属性，并将参数传递过去// 把创建的obj作为this的上下文
    
    
    if (result && ( typeof (result) == 'object' || typeof (result) == 'function')) {
      return result;
    }
    
    return obj;
}
```







## 数组去重

### 一. 借用Set去重

   ```js
const arr = [1,2,2,3,3]

const newArr = Array.from( new Set(arr))
   ```

### 二. 通过filter和indexof配合

   ```js
const arr = [1,2,2,3,3]

const flat = (arr) => {
	const newArr = arr.filter((item, index) => {
        return arr.indexOf(item) ===index
    })
    return newArr
}


flat(arr)


   ```

   

### 三. 通过循环

```js
   const arr = [1,2,2,3,3]
   
   const flat = (arr) => {
       const newArr = []
   		arr.forEach((item) => {
            if(!newArr.includes(item)) {
				newArr.push(item)
            }
   		})
       return newArr
   }
   
   
   flat(arr)

```















## new关键字

### object联想到创建对象的步骤

1. 创建新的一个空对象
2. 将new操作符调用的构造函数的prototype原型对象指向新创建的空对象
3. 将这个对象作为该函数执行的上下文(this)
4. 如果该函数没有返回值或者返回值不是引用类型,则返回上面的对象



### new

创建一个继承了所有属性（原型和直系属性）的对象
`注意：`
如果构造函数最终返回对象、函数、数组、日期等其他引用类型，会将其直接返回，其他基本类型及null、undefined会返回内部新创建的对象实例。



**new做了什么？**

- 先创建了一个空的对象
- 继承原型
- 把创建的obj作为this的上下文
- 判断构造函数的返回值




### 实现

```js
function newFunction(ConsFun, ...rest){
    const obj = {}
    obj._proto_ = ConsFun.prototype; // 继承原型
    const result = this.apply(obj, rest); // 执行ConsFun构造函数中的属性，并将参数传递过去// 把创建的obj作为this的上下文
    
    
    if (result && ( typeof (result) == 'object' || typeof (result) == 'function')) {
      return result;
    }
    
    return obj;
}
```





## apply、call、bind实现

call

思路：把函数作为对象的属性，这样就相当于使用对象来调用函数，即this指向为指定的对象

```js
Function.prototype.call = function(obj = window, ...args) {  // 指定的 this 如果是 undefined，就得用 window 对象
  const func = Symbol('func'); // 保持属性名的唯一性，防止和对象中的原有属性名发生冲突
  obj[func] = this; // Symbol类型的属性在对象中不能用.来访问

  const result = obj[func](...args);
  delete obj[func]; // 使用指定对象调用函数后，把函数从指定对象中删除

  return result;
}
```

apply

```js
Function.prototype.apply2 = function(obj = window, params) {
  const func = Symbol('func');
  obj[func] = this;

  const result = obj[func](...params); // apply传过来的是一个数组，所有直接结构就好了
  delete obj[func];

  return result;
}
```

bind

```js
Function.prototype.bindNew = function (obj, ...args) {
  if (typeof this !== "function") { throw Error("not a function.") } // 是否为函数_若不考虑参数类型可以省略
  return (...newArgs) => this.apply(obj, [...args, ...newArgs]); // 返回函数
};
```





## 防抖函数

### 手写防抖

```js
 // 防抖函数
function debounce (fn, delay) {
  var timer; // 维护一个 timer

  console.log(111);
  return function () {
    var _this = this; // 取debounce执行作用域的this
    var args = arguments;

    console.log(222);

    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(function () {
      fn.apply(_this, args); // 用apply指向调用debounce的对象，相当于_this.fn(args);
    }, delay);
  };
}

```



### 如何在react中使用useDebounce













## 手写节流





## 数组扁平化

  1. 使用flat

```js
const arr = [1, [2, 3], [4, [5, [6, 7], 8], 9], [[[[[[[[10]]]]]]]]];

const result = arr.flat(Infinity)
```

2. 使用递归

```js
const res5 = [];
const fn = arr => {
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      fn(arr[i]);
    } else {
      res5.push(arr[i]);
    }
  }
}
fn(arr);
```



## 数组去重

### 一. 借用Set去重

   ```js
const arr = [1,2,2,3,3]

const newArr = Array.from( new Set(arr))
   ```

### 二. 通过filter和indexof配合

   ```js
const arr = [1,2,2,3,3]

const removeRepeat = (arr) => {
	const newArr = arr.filter((item, index) => {
        return arr.indexOf(item) ===index
    })
    return newArr
}


removeRepeat(arr)


   ```

   

### 三. 通过循环

```js
   const arr = [1,2,2,3,3]
   
   const removeRepeat = (arr) => {
       const newArr = []
   		arr.forEach((item) => {
            if(!newArr.includes(item)) {
				newArr.push(item)
            }
   		})
       return newArr
   }
   
   
   removeRepeat(arr)

```







































