### 强类型语言和弱类型语言的区别

- **强类型语言**：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。
- **弱类型语言**：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换。

两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。

##### 为什么说js是单线程，而不是多线程呢，说说你的理解

> JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。
>
> 比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

### 什么是尾调用，使用尾调用有什么好处？

尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。

# [javascript逻辑运算符“||”和“&&”](https://www.cnblogs.com/pigtail/archive/2012/03/09/2387486.html)

一、先来说说||（逻辑或）,从字面上来说，只有前后都是false的时候才返回false，否则返回true。

```
alert(true||false);    // true
alert(false||true);    // true
alert(true||true);        // true
alert(false||false);    // false
```

但是，从深层意义上来说的话，却有另一番天地，试下面代码

```
alert(0||1);
```

显然，我们知道，前面0意味着false,而后面1意味着true,那么上面的结果应该是true,而事实返回的结果是1。再看下面代码：

```
alert(2||1);
```

我们知道，前面2是true,后面1也是true,那返回结果又是什么呢？测试结果是2,继续看：

```
alert('a'||1);
```

同样，前面'a'是true，后面1也是true;测试结果是'a',下面

```
alert(''||1);
```

由上，我们知道前面''是false,后面1是true,而返回结果是1。再看下面

```
alert('a'||0);
```

 前面'a'是true，而后面0是false,返回结果是'a'，继续下面

```
alert('a'||'b');
```

 前面'a'是true,后面'b'是false,返回结果是'a'，我们继续下面

```
alert(''||0);
```

 前面''是false,后面0同样是false,返回结果是0

```
alert(0||'');
```

前面0是false，后面''是false，返回结果是''

 

这就意味

1、只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。

2、只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。

 

\----------------------------------------------------------------------------------------------------------


二、下面说说&&（逻辑与）,从字面上来说，只有前后都是true的时候才返回true，否则返回false。

```
alert(true&&false);    // false
alert(true&&true);    // true
alert(false&&false);    // false
alert(false&&true);    // false
```

然后，根据上面经验，我们看看“&&”号前后，不单单是布尔类型的情况。

```
alert(''&&1);
```

结是返回'',“&&”前面''是false,后面是1是true。

```
alert(''&&0);
```

结是返回'',“&&”前面''是false,后面是0也是false。

```
alert('a'&&1);
```

结是返回1,“&&”前面''a是true,后面是1也是true。

```
alert('a'&&0);
```

结是返回0,“&&”前面''a是true,后面是0是false。

```
alert('a'&&'');
```

结是返回'',“&&”前面''a是true,后面是''是false。

```
alert(0&&'a');
```

结是返回0,“&&”前面''0是false,后面是'a'是true。

```
alert(0&&'');
```

结是返回0,“&&”前面''0是false,后面是''也是false。

 

这意味着

1、只要“&&”前面是false，无论“&&”后面是true还是false，结果都将返“&&”前面的值;

2、只要“&&”前面是true，无论“&&”后面是true还是false，结果都将返“&&”后面的值;

 

 

让我们总结一下：

1、只要“||”前面为false，无论“||”后面是true还是false，结果都返回“||”后面的值。

2、只要“||”前面为true，无论“||”后面是true还是false，结果都返回“||”前面的值。

3、只要“&&”前面是false，无论“&&”后面是true还是false，结果都将返“&&”前面的值;

4、只要“&&”前面是true，无论“&&”后面是true还是false，结果都将返“&&”后面的值;


由上两个测试可知，逻辑运算符，“||”和“&&”都是遵行短路原则，只要确定符号前面的真假，既可确定返回值。

需要说明的是“&&”的优先级是高于“||”的，下面测试：

```
alert(1||'a'&&2);
```

返回结果是1。

根据反证原理，我们假设“||”的优先级不低于“&&”（这里只所以用“不低于”，是为了同时证明等级相同的情况）。

根据上面我们得出的结论（1），（1||'a'）将返回前面的值1，(1&&2)根据结论(4)应该返回后面的值2。这显然不对，由此可知“&&”的优先级是高于“||”的。
