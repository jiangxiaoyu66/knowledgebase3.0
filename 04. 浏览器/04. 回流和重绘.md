# 回流和重绘



## 1、重排和重绘

说完浏览器引擎的渲染流程，再来看两个重要的概念：重排（Reflow）和重绘（Repaint）。 

渲染树是动态构建的，所以，DOM节点和CSS节点的改动都可能会造成渲染树的重新构建。渲染树的改动就会造成页面的重排或者重绘。

### （1）重排

**当我们的操作引发了 DOM 树中几何尺寸的变化（改变元素的大小、位置、布局方式等），这时渲染树里有改动的节点和它影响的节点都要重新计算。**这个过程就叫做重排，也称为回流。在改动发生时，要重新经历页面渲染的整个流程，所以开销是很大的。 

以下操作都会导致页面重排：

- 页面首次渲染；
- 浏览器窗口大小发生变化；
- 元素的内容发生变化；
- 元素的尺寸或者位置发生变化；
- 元素的字体大小发生变化；
- 激活CSS伪类；
- 查询某些属性或者调用某些方法；
- 添加或者删除可见的DOM元素。

在触发重排时，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：

- 全局范围：从根节点开始，对整个渲染树进行重新布局；
- 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局。

### （2）重绘

当对 DOM 的修改导致了样式的变化、但未影响其几何尺寸（比如只是修改颜色、背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（会跳过重排环节），这个过程叫做重绘。简单来说，重绘是由对元素绘制属性的修改引发的。 

当我们修改元素绘制属性时，页面布局阶段不会执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

**下面这些属性会导致回流：**

- color、background 相关属性：background-color、background-image 等；
- outline 相关属性：outline-color、outline-width 、text-decoration；
- border-radius、visibility、box-shadow。

扩展：[关于outline属性](https://www.w3school.com.cn/cssref/pr_outline.asp)

注意： **当触发重排时，一定会触发重绘，但是重绘不一定会引发重排。**

## 2、如何优化

### 要做什么

1.**CSS3 硬件加速（GPU加速）**，尽量使用 CSS3 动画，它可以调用 GPU 执行渲染

使用transform，opacity，filters，will-change，触发CSS3硬件加速，避免回流重绘

2.**对具有复杂动画的元素使用绝对定位**，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

### 不要做什么

1、**避免使用`table`布局**，可能很小的一个小改动会造成整个 `table` 的重新布局。

2、**避免使用`CSS`表达式**，可能会引发回流。

解释：CSS 表达式致命的一点是，它执行的频率远远超出了你的想象。理想情况是，我们希望这个表达式在页面加载或刷新的时候执行。事与愿违，只要页面一滚动，它就会重复执行，甚至鼠标移动的时候，它也会执行。
　　要知道80% 的用户喜欢使用鼠标在页面上移动，来帮助他们阅读或者根本就是漫无目的的移动。那就可以想象当用户阅读文章的时候，鼠标的移动量会有多大。因为CSS 表达式在鼠标移动的时候就会执行，所以光看这一个页面，CSS 表达式就执行上千遍，甚至上万遍。这对于用户体验来说简直就是灾难。

3、不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。

4、避免频繁操作DOM，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中

1. 将元素先设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
2. 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于**浏览器的渲染队列机制**。

浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列，** 浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。



